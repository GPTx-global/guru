// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: guru/oracle/v1/oracle.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type PredefinedOracleType int32

const (
	// Default value, should not be used
	PredefinedOracleType_PREDEFINED_ORACLE_TYPE_UNSPECIFIED PredefinedOracleType = 0
	// Minimum gas price oracle for network fee estimation
	PredefinedOracleType_PREDEFINED_ORACLE_TYPE_MIN_GAS_PRICE PredefinedOracleType = 1
	// Currency exchange rates and forex data (KRW)
	PredefinedOracleType_PREDEFINED_ORACLE_TYPE_CURRENCY_KRW PredefinedOracleType = 2
	// Currency exchange rates and forex data (USD)
	PredefinedOracleType_PREDEFINED_ORACLE_TYPE_CURRENCY_USD PredefinedOracleType = 3
	// Currency exchange rates and forex data (EUR)
	PredefinedOracleType_PREDEFINED_ORACLE_TYPE_CURRENCY_EUR PredefinedOracleType = 4
	// Currency exchange rates and forex data (JPY)
	PredefinedOracleType_PREDEFINED_ORACLE_TYPE_CURRENCY_JPY PredefinedOracleType = 5
	// Currency exchange rates and forex data (CNY)
	PredefinedOracleType_PREDEFINED_ORACLE_TYPE_CURRENCY_CNY PredefinedOracleType = 6
	// Currency exchange rates and forex data (PHP)
	PredefinedOracleType_PREDEFINED_ORACLE_TYPE_CURRENCY_PHP PredefinedOracleType = 7
	// Currency exchange rates and forex data (AUD)
	PredefinedOracleType_PREDEFINED_ORACLE_TYPE_CURRENCY_AUD PredefinedOracleType = 8
	// Currency exchange rates and forex data (CAD)
	PredefinedOracleType_PREDEFINED_ORACLE_TYPE_CURRENCY_CAD PredefinedOracleType = 9
	// Currency exchange rates and forex data (HKD)
	PredefinedOracleType_PREDEFINED_ORACLE_TYPE_CURRENCY_HKD PredefinedOracleType = 10
)

var PredefinedOracleType_name = map[int32]string{
	0:  "PREDEFINED_ORACLE_TYPE_UNSPECIFIED",
	1:  "PREDEFINED_ORACLE_TYPE_MIN_GAS_PRICE",
	2:  "PREDEFINED_ORACLE_TYPE_CURRENCY_KRW",
	3:  "PREDEFINED_ORACLE_TYPE_CURRENCY_USD",
	4:  "PREDEFINED_ORACLE_TYPE_CURRENCY_EUR",
	5:  "PREDEFINED_ORACLE_TYPE_CURRENCY_JPY",
	6:  "PREDEFINED_ORACLE_TYPE_CURRENCY_CNY",
	7:  "PREDEFINED_ORACLE_TYPE_CURRENCY_PHP",
	8:  "PREDEFINED_ORACLE_TYPE_CURRENCY_AUD",
	9:  "PREDEFINED_ORACLE_TYPE_CURRENCY_CAD",
	10: "PREDEFINED_ORACLE_TYPE_CURRENCY_HKD",
}

var PredefinedOracleType_value = map[string]int32{
	"PREDEFINED_ORACLE_TYPE_UNSPECIFIED":   0,
	"PREDEFINED_ORACLE_TYPE_MIN_GAS_PRICE": 1,
	"PREDEFINED_ORACLE_TYPE_CURRENCY_KRW":  2,
	"PREDEFINED_ORACLE_TYPE_CURRENCY_USD":  3,
	"PREDEFINED_ORACLE_TYPE_CURRENCY_EUR":  4,
	"PREDEFINED_ORACLE_TYPE_CURRENCY_JPY":  5,
	"PREDEFINED_ORACLE_TYPE_CURRENCY_CNY":  6,
	"PREDEFINED_ORACLE_TYPE_CURRENCY_PHP":  7,
	"PREDEFINED_ORACLE_TYPE_CURRENCY_AUD":  8,
	"PREDEFINED_ORACLE_TYPE_CURRENCY_CAD":  9,
	"PREDEFINED_ORACLE_TYPE_CURRENCY_HKD":  10,
}

func (x PredefinedOracleType) String() string {
	return proto.EnumName(PredefinedOracleType_name, int32(x))
}

func (PredefinedOracleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{0}
}

// OracleType defines the type of oracle data that can be requested and provided
// This enum helps categorize different kinds of oracle data sources and their purposes
type OracleType int32

const (
	// Default value, should not be used
	OracleType_ORACLE_TYPE_UNSPECIFIED OracleType = 0
	// Minimum gas price oracle for network fee estimation
	OracleType_ORACLE_TYPE_MIN_GAS_PRICE OracleType = 1
	// Currency exchange rates and forex data
	OracleType_ORACLE_TYPE_CURRENCY OracleType = 2
	// Stock market data and indices
	OracleType_ORACLE_TYPE_STOCK OracleType = 3
	// Cryptocurrency prices and market data
	OracleType_ORACLE_TYPE_CRYPTO OracleType = 4
)

var OracleType_name = map[int32]string{
	0: "ORACLE_TYPE_UNSPECIFIED",
	1: "ORACLE_TYPE_MIN_GAS_PRICE",
	2: "ORACLE_TYPE_CURRENCY",
	3: "ORACLE_TYPE_STOCK",
	4: "ORACLE_TYPE_CRYPTO",
}

var OracleType_value = map[string]int32{
	"ORACLE_TYPE_UNSPECIFIED":   0,
	"ORACLE_TYPE_MIN_GAS_PRICE": 1,
	"ORACLE_TYPE_CURRENCY":      2,
	"ORACLE_TYPE_STOCK":         3,
	"ORACLE_TYPE_CRYPTO":        4,
}

func (x OracleType) String() string {
	return proto.EnumName(OracleType_name, int32(x))
}

func (OracleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{1}
}

// RequestStatus defines the current state of an oracle request
// This helps track the lifecycle of oracle data requests
type RequestStatus int32

const (
	// Default value, should not be used
	RequestStatus_REQUEST_STATUS_UNSPECIFIED RequestStatus = 0
	// Request is enabled
	RequestStatus_REQUEST_STATUS_ENABLED RequestStatus = 1
	// Request is paused
	RequestStatus_REQUEST_STATUS_PAUSED RequestStatus = 2
	// Request is disabled
	RequestStatus_REQUEST_STATUS_DISABLED RequestStatus = 3
)

var RequestStatus_name = map[int32]string{
	0: "REQUEST_STATUS_UNSPECIFIED",
	1: "REQUEST_STATUS_ENABLED",
	2: "REQUEST_STATUS_PAUSED",
	3: "REQUEST_STATUS_DISABLED",
}

var RequestStatus_value = map[string]int32{
	"REQUEST_STATUS_UNSPECIFIED": 0,
	"REQUEST_STATUS_ENABLED":     1,
	"REQUEST_STATUS_PAUSED":      2,
	"REQUEST_STATUS_DISABLED":    3,
}

func (x RequestStatus) String() string {
	return proto.EnumName(RequestStatus_name, int32(x))
}

func (RequestStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{2}
}

// AggregationRule defines the enumeration for aggregating oracle data
// Specifies how multiple data points should be combined into a single value
type AggregationRule int32

const (
	// Default value, should not be used
	AggregationRule_AGGREGATION_RULE_UNSPECIFIED AggregationRule = 0
	// Use average value to aggregate the data
	AggregationRule_AGGREGATION_RULE_AVG AggregationRule = 1
	// Use minimum value to aggregate the data
	AggregationRule_AGGREGATION_RULE_MIN AggregationRule = 2
	// Use maximum value to aggregate the data
	AggregationRule_AGGREGATION_RULE_MAX AggregationRule = 3
	// Use median value to aggregate the data
	AggregationRule_AGGREGATION_RULE_MEDIAN AggregationRule = 4
)

var AggregationRule_name = map[int32]string{
	0: "AGGREGATION_RULE_UNSPECIFIED",
	1: "AGGREGATION_RULE_AVG",
	2: "AGGREGATION_RULE_MIN",
	3: "AGGREGATION_RULE_MAX",
	4: "AGGREGATION_RULE_MEDIAN",
}

var AggregationRule_value = map[string]int32{
	"AGGREGATION_RULE_UNSPECIFIED": 0,
	"AGGREGATION_RULE_AVG":         1,
	"AGGREGATION_RULE_MIN":         2,
	"AGGREGATION_RULE_MAX":         3,
	"AGGREGATION_RULE_MEDIAN":      4,
}

func (x AggregationRule) String() string {
	return proto.EnumName(AggregationRule_name, int32(x))
}

func (AggregationRule) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{3}
}

// OracleRequestDoc defines the structure for oracle request documents
// This is the main document that describes what oracle data is needed and how it should be processed
type OracleRequestDoc struct {
	// Unique identifier for the oracle request
	RequestId uint64 `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Type of oracle data being requested
	OracleType OracleType `protobuf:"varint,2,opt,name=oracle_type,json=oracleType,proto3,enum=guru.oracle.v1.OracleType" json:"oracle_type,omitempty"`
	// Human-readable name for the oracle request
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Detailed description of what data is needed and its purpose
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Time period in seconds between data updates
	Period uint32 `protobuf:"varint,5,opt,name=period,proto3" json:"period,omitempty"`
	// List of account addresses that are authorized to provide data
	AccountList []string `protobuf:"bytes,6,rep,name=account_list,json=accountList,proto3" json:"account_list,omitempty"`
	// Minimum number of oracle nodes required to validate the data
	Quorum uint32 `protobuf:"varint,7,opt,name=quorum,proto3" json:"quorum,omitempty"`
	// Source endpoints where the data can be fetched
	Endpoints []*OracleEndpoint `protobuf:"bytes,8,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
	// Rule for aggregating multiple data points (e.g., median, mean)
	AggregationRule AggregationRule `protobuf:"varint,9,opt,name=aggregation_rule,json=aggregationRule,proto3,enum=guru.oracle.v1.AggregationRule" json:"aggregation_rule,omitempty"`
	// Current status of the request
	Status RequestStatus `protobuf:"varint,10,opt,name=status,proto3,enum=guru.oracle.v1.RequestStatus" json:"status,omitempty"`
	// Address of the request creator
	Creator string `protobuf:"bytes,11,opt,name=creator,proto3" json:"creator,omitempty"`
	// Sequential number to ensure data freshness
	Nonce uint64 `protobuf:"varint,12,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *OracleRequestDoc) Reset()         { *m = OracleRequestDoc{} }
func (m *OracleRequestDoc) String() string { return proto.CompactTextString(m) }
func (*OracleRequestDoc) ProtoMessage()    {}
func (*OracleRequestDoc) Descriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{0}
}
func (m *OracleRequestDoc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleRequestDoc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleRequestDoc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleRequestDoc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleRequestDoc.Merge(m, src)
}
func (m *OracleRequestDoc) XXX_Size() int {
	return m.Size()
}
func (m *OracleRequestDoc) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleRequestDoc.DiscardUnknown(m)
}

var xxx_messageInfo_OracleRequestDoc proto.InternalMessageInfo

func (m *OracleRequestDoc) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *OracleRequestDoc) GetOracleType() OracleType {
	if m != nil {
		return m.OracleType
	}
	return OracleType_ORACLE_TYPE_UNSPECIFIED
}

func (m *OracleRequestDoc) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OracleRequestDoc) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *OracleRequestDoc) GetPeriod() uint32 {
	if m != nil {
		return m.Period
	}
	return 0
}

func (m *OracleRequestDoc) GetAccountList() []string {
	if m != nil {
		return m.AccountList
	}
	return nil
}

func (m *OracleRequestDoc) GetQuorum() uint32 {
	if m != nil {
		return m.Quorum
	}
	return 0
}

func (m *OracleRequestDoc) GetEndpoints() []*OracleEndpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *OracleRequestDoc) GetAggregationRule() AggregationRule {
	if m != nil {
		return m.AggregationRule
	}
	return AggregationRule_AGGREGATION_RULE_UNSPECIFIED
}

func (m *OracleRequestDoc) GetStatus() RequestStatus {
	if m != nil {
		return m.Status
	}
	return RequestStatus_REQUEST_STATUS_UNSPECIFIED
}

func (m *OracleRequestDoc) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *OracleRequestDoc) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type OracleEndpoint struct {
	// URL of the oracle endpoint
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// Type of the oracle endpoint
	ParseRule string `protobuf:"bytes,2,opt,name=parse_rule,json=parseRule,proto3" json:"parse_rule,omitempty"`
}

func (m *OracleEndpoint) Reset()         { *m = OracleEndpoint{} }
func (m *OracleEndpoint) String() string { return proto.CompactTextString(m) }
func (*OracleEndpoint) ProtoMessage()    {}
func (*OracleEndpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{1}
}
func (m *OracleEndpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleEndpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OracleEndpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OracleEndpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleEndpoint.Merge(m, src)
}
func (m *OracleEndpoint) XXX_Size() int {
	return m.Size()
}
func (m *OracleEndpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleEndpoint.DiscardUnknown(m)
}

var xxx_messageInfo_OracleEndpoint proto.InternalMessageInfo

func (m *OracleEndpoint) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *OracleEndpoint) GetParseRule() string {
	if m != nil {
		return m.ParseRule
	}
	return ""
}

// SubmitDataSet defines the structure for oracle data sets for submit
// This represents a single data point provided by an oracle node
type SubmitDataSet struct {
	// ID of the request this data set belongs to
	RequestId uint64 `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Sequential number to prevent replay attacks
	Nonce uint64 `protobuf:"varint,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Raw data in string format (can be JSON, CSV, etc.)
	RawData string `protobuf:"bytes,3,opt,name=raw_data,json=rawData,proto3" json:"raw_data,omitempty"`
	// Address of the data provider
	Provider string `protobuf:"bytes,4,opt,name=provider,proto3" json:"provider,omitempty"`
	// Cryptographic signature of the data for verification
	Signature string `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *SubmitDataSet) Reset()         { *m = SubmitDataSet{} }
func (m *SubmitDataSet) String() string { return proto.CompactTextString(m) }
func (*SubmitDataSet) ProtoMessage()    {}
func (*SubmitDataSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{2}
}
func (m *SubmitDataSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitDataSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitDataSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitDataSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitDataSet.Merge(m, src)
}
func (m *SubmitDataSet) XXX_Size() int {
	return m.Size()
}
func (m *SubmitDataSet) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitDataSet.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitDataSet proto.InternalMessageInfo

func (m *SubmitDataSet) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *SubmitDataSet) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *SubmitDataSet) GetRawData() string {
	if m != nil {
		return m.RawData
	}
	return ""
}

func (m *SubmitDataSet) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *SubmitDataSet) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

// DataSet defines the structure for oracle data sets
type DataSet struct {
	// request_id represents the ID of the request this data set belongs to
	RequestId uint64 `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// nonce represents the sequential number to prevent replay attacks
	Nonce uint64 `protobuf:"varint,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// block_height represents the height of the block where the data was aggregated
	BlockHeight uint64 `protobuf:"varint,3,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// block_time represents the time of the block where the data was aggregated
	BlockTime uint64 `protobuf:"varint,4,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
	// raw_data represents the raw data in string format (can be JSON, CSV, etc.)
	RawData string `protobuf:"bytes,5,opt,name=raw_data,json=rawData,proto3" json:"raw_data,omitempty"`
}

func (m *DataSet) Reset()         { *m = DataSet{} }
func (m *DataSet) String() string { return proto.CompactTextString(m) }
func (*DataSet) ProtoMessage()    {}
func (*DataSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{3}
}
func (m *DataSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSet.Merge(m, src)
}
func (m *DataSet) XXX_Size() int {
	return m.Size()
}
func (m *DataSet) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSet.DiscardUnknown(m)
}

var xxx_messageInfo_DataSet proto.InternalMessageInfo

func (m *DataSet) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *DataSet) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *DataSet) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *DataSet) GetBlockTime() uint64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *DataSet) GetRawData() string {
	if m != nil {
		return m.RawData
	}
	return ""
}

// PredefinedOracle defines the structure for predefined oracles
// This is a predefined oracle that is used to fetch data from an external source
type PredefinedOracle struct {
	// name represents the name of the predefined oracle
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// type represents the type of the predefined oracle
	Type PredefinedOracleType `protobuf:"varint,2,opt,name=type,proto3,enum=guru.oracle.v1.PredefinedOracleType" json:"type,omitempty"`
	// request_id represents the ID of the request this predefined oracle belongs to
	RequestId uint64 `protobuf:"varint,3,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
}

func (m *PredefinedOracle) Reset()         { *m = PredefinedOracle{} }
func (m *PredefinedOracle) String() string { return proto.CompactTextString(m) }
func (*PredefinedOracle) ProtoMessage()    {}
func (*PredefinedOracle) Descriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{4}
}
func (m *PredefinedOracle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PredefinedOracle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PredefinedOracle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PredefinedOracle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PredefinedOracle.Merge(m, src)
}
func (m *PredefinedOracle) XXX_Size() int {
	return m.Size()
}
func (m *PredefinedOracle) XXX_DiscardUnknown() {
	xxx_messageInfo_PredefinedOracle.DiscardUnknown(m)
}

var xxx_messageInfo_PredefinedOracle proto.InternalMessageInfo

func (m *PredefinedOracle) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PredefinedOracle) GetType() PredefinedOracleType {
	if m != nil {
		return m.Type
	}
	return PredefinedOracleType_PREDEFINED_ORACLE_TYPE_UNSPECIFIED
}

func (m *PredefinedOracle) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func init() {
	proto.RegisterEnum("guru.oracle.v1.PredefinedOracleType", PredefinedOracleType_name, PredefinedOracleType_value)
	proto.RegisterEnum("guru.oracle.v1.OracleType", OracleType_name, OracleType_value)
	proto.RegisterEnum("guru.oracle.v1.RequestStatus", RequestStatus_name, RequestStatus_value)
	proto.RegisterEnum("guru.oracle.v1.AggregationRule", AggregationRule_name, AggregationRule_value)
	proto.RegisterType((*OracleRequestDoc)(nil), "guru.oracle.v1.OracleRequestDoc")
	proto.RegisterType((*OracleEndpoint)(nil), "guru.oracle.v1.OracleEndpoint")
	proto.RegisterType((*SubmitDataSet)(nil), "guru.oracle.v1.SubmitDataSet")
	proto.RegisterType((*DataSet)(nil), "guru.oracle.v1.DataSet")
	proto.RegisterType((*PredefinedOracle)(nil), "guru.oracle.v1.PredefinedOracle")
}

func init() { proto.RegisterFile("guru/oracle/v1/oracle.proto", fileDescriptor_f372f15f6da5f250) }

var fileDescriptor_f372f15f6da5f250 = []byte{
	// 948 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x36, 0x45, 0xf9, 0x47, 0xe3, 0x9f, 0x6c, 0x17, 0x8e, 0x4b, 0x2b, 0xb1, 0xa2, 0xa8, 0x41,
	0x2b, 0x18, 0xa8, 0x05, 0xa7, 0x28, 0x50, 0xa0, 0xbd, 0x30, 0x22, 0x23, 0x2b, 0x76, 0x64, 0x76,
	0x49, 0xb5, 0x75, 0x2f, 0xc4, 0x8a, 0xda, 0xd0, 0x44, 0x25, 0xae, 0x42, 0x2e, 0x9d, 0xe4, 0xd4,
	0x43, 0x5f, 0xa0, 0x3d, 0x16, 0x05, 0xfa, 0x3c, 0x3d, 0xe6, 0xd8, 0xde, 0x0a, 0xfb, 0xd2, 0xc7,
	0x28, 0xb8, 0x64, 0x6c, 0x89, 0xb6, 0x5b, 0x01, 0xb9, 0xed, 0xcc, 0xf7, 0xcd, 0xec, 0x37, 0x3b,
	0x33, 0x12, 0xe1, 0x9e, 0x9f, 0x44, 0x49, 0x8b, 0x47, 0xd4, 0x1b, 0xb1, 0xd6, 0xd9, 0x7e, 0x7e,
	0xda, 0x9b, 0x44, 0x5c, 0x70, 0xbc, 0x91, 0x82, 0x7b, 0xb9, 0xeb, 0x6c, 0xbf, 0xba, 0xe9, 0x73,
	0x9f, 0x4b, 0xa8, 0x95, 0x9e, 0x32, 0x56, 0xf5, 0x81, 0xcf, 0xb9, 0x3f, 0x62, 0x2d, 0x69, 0x0d,
	0x92, 0x17, 0x2d, 0x11, 0x8c, 0x59, 0x2c, 0xe8, 0x78, 0x92, 0x13, 0x6a, 0x1e, 0x8f, 0xc7, 0x3c,
	0x6e, 0x0d, 0x68, 0x9c, 0xde, 0x31, 0x60, 0x82, 0xee, 0xb7, 0x3c, 0x1e, 0x84, 0x19, 0xde, 0xf8,
	0x47, 0x05, 0x74, 0x2c, 0x2f, 0x21, 0xec, 0x65, 0xc2, 0x62, 0x61, 0x70, 0x0f, 0xef, 0x00, 0x44,
	0x99, 0xe5, 0x06, 0x43, 0x4d, 0xa9, 0x2b, 0xcd, 0x32, 0xa9, 0xe4, 0x9e, 0xee, 0x10, 0x7f, 0x09,
	0xab, 0x99, 0x2e, 0x57, 0xbc, 0x99, 0x30, 0xad, 0x54, 0x57, 0x9a, 0x1b, 0x8f, 0xab, 0x7b, 0xb3,
	0x82, 0xf7, 0xb2, 0xac, 0xce, 0x9b, 0x09, 0x23, 0xc0, 0x2f, 0xcf, 0x18, 0x43, 0x39, 0xa4, 0x63,
	0xa6, 0xa9, 0x75, 0xa5, 0x59, 0x21, 0xf2, 0x8c, 0xeb, 0xb0, 0x3a, 0x64, 0xb1, 0x17, 0x05, 0x13,
	0x11, 0xf0, 0x50, 0x2b, 0x4b, 0x68, 0xda, 0x85, 0xb7, 0x60, 0x69, 0xc2, 0xa2, 0x80, 0x0f, 0xb5,
	0xc5, 0xba, 0xd2, 0x5c, 0x27, 0xb9, 0x85, 0x1f, 0xc2, 0x1a, 0xf5, 0x3c, 0x9e, 0x84, 0xc2, 0x1d,
	0x05, 0xb1, 0xd0, 0x96, 0xea, 0x6a, 0x1a, 0x9a, 0xfb, 0x8e, 0x82, 0x58, 0xa4, 0xa1, 0x2f, 0x13,
	0x1e, 0x25, 0x63, 0x6d, 0x39, 0x0b, 0xcd, 0x2c, 0xfc, 0x15, 0x54, 0x58, 0x38, 0x9c, 0xf0, 0x20,
	0x14, 0xb1, 0xb6, 0x52, 0x57, 0x9b, 0xab, 0x8f, 0x6b, 0x37, 0xd7, 0x60, 0xe6, 0x34, 0x72, 0x15,
	0x80, 0x9f, 0x01, 0xa2, 0xbe, 0x1f, 0x31, 0x9f, 0xa6, 0xfa, 0xdc, 0x28, 0x19, 0x31, 0xad, 0x22,
	0x1f, 0xe2, 0x41, 0x31, 0x89, 0x7e, 0xc5, 0x23, 0xc9, 0x88, 0x91, 0x3b, 0x74, 0xd6, 0x81, 0x3f,
	0x87, 0xa5, 0x58, 0x50, 0x91, 0xc4, 0x1a, 0xc8, 0x0c, 0x3b, 0xc5, 0x0c, 0x79, 0x6b, 0x6c, 0x49,
	0x22, 0x39, 0x19, 0x6b, 0xb0, 0xec, 0x45, 0x8c, 0x0a, 0x1e, 0x69, 0xab, 0xf2, 0xc5, 0xde, 0x99,
	0x78, 0x13, 0x16, 0x43, 0x1e, 0x7a, 0x4c, 0x5b, 0x93, 0xad, 0xcb, 0x8c, 0x86, 0x0e, 0x1b, 0xb3,
	0xf5, 0x60, 0x04, 0x6a, 0x12, 0x8d, 0x64, 0x83, 0x2b, 0x24, 0x3d, 0xa6, 0x9d, 0x9f, 0xd0, 0x28,
	0x66, 0x59, 0x41, 0x25, 0x09, 0x54, 0xa4, 0x27, 0x55, 0xda, 0xf8, 0x55, 0x81, 0x75, 0x3b, 0x19,
	0x8c, 0x03, 0x61, 0x50, 0x41, 0x6d, 0x26, 0xfe, 0x6f, 0x54, 0x2e, 0x95, 0x94, 0xa6, 0x94, 0xe0,
	0x6d, 0x58, 0x89, 0xe8, 0x2b, 0x77, 0x48, 0x05, 0xcd, 0xe7, 0x60, 0x39, 0xa2, 0xaf, 0xd2, 0x94,
	0xb8, 0x0a, 0x2b, 0x93, 0x88, 0x9f, 0x05, 0x43, 0x16, 0xe5, 0x73, 0x70, 0x69, 0xe3, 0xfb, 0x50,
	0x89, 0x03, 0x3f, 0xa4, 0x22, 0x89, 0x98, 0x9c, 0x83, 0x0a, 0xb9, 0x72, 0x34, 0x7e, 0x53, 0x60,
	0xf9, 0xbd, 0x54, 0x3d, 0x84, 0xb5, 0xc1, 0x88, 0x7b, 0x3f, 0xb8, 0xa7, 0x2c, 0xf0, 0x4f, 0x85,
	0x54, 0x56, 0x26, 0xab, 0xd2, 0x77, 0x20, 0x5d, 0x69, 0xde, 0x8c, 0x92, 0xae, 0x99, 0xd4, 0x57,
	0x26, 0x15, 0xe9, 0x71, 0x82, 0xf1, 0x6c, 0x5d, 0x8b, 0x33, 0x75, 0x35, 0x7e, 0x04, 0x64, 0x45,
	0x6c, 0xc8, 0x5e, 0x04, 0x21, 0x1b, 0x66, 0x6d, 0xb8, 0x5c, 0x05, 0x65, 0x6a, 0x15, 0xbe, 0x80,
	0xf2, 0xd4, 0x52, 0x3d, 0x2a, 0x4e, 0x42, 0x31, 0x87, 0x5c, 0x2f, 0x19, 0x51, 0xa8, 0x59, 0x2d,
	0xd4, 0xbc, 0xfb, 0x97, 0x0a, 0x9b, 0x37, 0x45, 0xe3, 0x8f, 0xa1, 0x61, 0x11, 0xd3, 0x30, 0x9f,
	0x76, 0x7b, 0xa6, 0xe1, 0x1e, 0x13, 0xbd, 0x7d, 0x64, 0xba, 0xce, 0x89, 0x65, 0xba, 0xfd, 0x9e,
	0x6d, 0x99, 0xed, 0xee, 0xd3, 0xae, 0x69, 0xa0, 0x05, 0xdc, 0x84, 0x47, 0xb7, 0xf0, 0x9e, 0x77,
	0x7b, 0x6e, 0x47, 0xb7, 0x5d, 0x8b, 0x74, 0xdb, 0x26, 0x52, 0xf0, 0x27, 0xf0, 0xd1, 0x2d, 0xcc,
	0x76, 0x9f, 0x10, 0xb3, 0xd7, 0x3e, 0x71, 0x0f, 0xc9, 0xb7, 0xa8, 0x34, 0x0f, 0xb1, 0x6f, 0x1b,
	0x48, 0x9d, 0x87, 0x68, 0xf6, 0x09, 0x2a, 0xcf, 0x43, 0x7c, 0x66, 0x9d, 0xa0, 0xc5, 0x79, 0x88,
	0xed, 0xde, 0x09, 0x5a, 0x9a, 0x87, 0x68, 0x1d, 0x58, 0x68, 0x79, 0x1e, 0xa2, 0xde, 0x37, 0xd0,
	0xca, 0x5c, 0x57, 0xeb, 0x06, 0xaa, 0xcc, 0x43, 0x3c, 0x38, 0x34, 0x10, 0xec, 0xfe, 0xa2, 0x00,
	0x4c, 0x75, 0xf4, 0x1e, 0x7c, 0x78, 0x7b, 0x1b, 0x77, 0x60, 0xfb, 0xbf, 0x7a, 0xa7, 0xc1, 0xe6,
	0x4d, 0x17, 0xa1, 0x12, 0xbe, 0x0b, 0x1f, 0x4c, 0x23, 0xb6, 0x73, 0xdc, 0x3e, 0x44, 0x2a, 0xde,
	0x02, 0x3c, 0x13, 0x40, 0x4e, 0x2c, 0xe7, 0x18, 0x95, 0x77, 0x7f, 0x52, 0x60, 0x7d, 0xe6, 0x77,
	0x0b, 0xd7, 0xa0, 0x4a, 0xcc, 0xaf, 0xfb, 0xa6, 0xed, 0xb8, 0xb6, 0xa3, 0x3b, 0x7d, 0xbb, 0xa0,
	0xac, 0x0a, 0x5b, 0x05, 0xdc, 0xec, 0xe9, 0x4f, 0x8e, 0x4c, 0x03, 0x29, 0x78, 0x1b, 0xee, 0x16,
	0x30, 0x4b, 0xef, 0xdb, 0xa6, 0x81, 0x4a, 0x69, 0xb5, 0x05, 0xc8, 0xe8, 0xda, 0x59, 0x9c, 0xba,
	0xfb, 0xbb, 0x02, 0x77, 0x0a, 0xbf, 0xbf, 0xb8, 0x0e, 0xf7, 0xf5, 0x4e, 0x87, 0x98, 0x1d, 0xdd,
	0xe9, 0x1e, 0xf7, 0x5c, 0xd2, 0x3f, 0x2a, 0xbe, 0x91, 0x06, 0x9b, 0xd7, 0x18, 0xfa, 0x37, 0x9d,
	0xec, 0x79, 0xae, 0x21, 0xcf, 0xbb, 0x3d, 0x54, 0xba, 0x19, 0xd1, 0xbf, 0x43, 0x6a, 0x2a, 0xf0,
	0x3a, 0x62, 0x1a, 0x5d, 0xbd, 0x87, 0xca, 0x4f, 0x8c, 0x3f, 0xce, 0x6b, 0xca, 0xdb, 0xf3, 0x9a,
	0xf2, 0xf7, 0x79, 0x4d, 0xf9, 0xf9, 0xa2, 0xb6, 0xf0, 0xf6, 0xa2, 0xb6, 0xf0, 0xe7, 0x45, 0x6d,
	0xe1, 0xfb, 0x5d, 0x3f, 0x10, 0xa7, 0xc9, 0x60, 0xcf, 0xe3, 0xe3, 0x56, 0xc7, 0x72, 0x5e, 0x7f,
	0xea, 0x8f, 0xf8, 0x80, 0x8e, 0x5a, 0xf2, 0xa3, 0xe1, 0xf5, 0xbb, 0xcf, 0x86, 0x74, 0xf5, 0xe3,
	0xc1, 0x92, 0xfc, 0x33, 0xff, 0xec, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x90, 0x68, 0x10, 0x11,
	0x52, 0x08, 0x00, 0x00,
}

func (m *OracleRequestDoc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleRequestDoc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleRequestDoc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Status != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	if m.AggregationRule != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.AggregationRule))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Endpoints) > 0 {
		for iNdEx := len(m.Endpoints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Endpoints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOracle(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Quorum != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Quorum))
		i--
		dAtA[i] = 0x38
	}
	if len(m.AccountList) > 0 {
		for iNdEx := len(m.AccountList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AccountList[iNdEx])
			copy(dAtA[i:], m.AccountList[iNdEx])
			i = encodeVarintOracle(dAtA, i, uint64(len(m.AccountList[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Period != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Period))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OracleType != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OracleEndpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleEndpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleEndpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParseRule) > 0 {
		i -= len(m.ParseRule)
		copy(dAtA[i:], m.ParseRule)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ParseRule)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubmitDataSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitDataSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubmitDataSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RawData) > 0 {
		i -= len(m.RawData)
		copy(dAtA[i:], m.RawData)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.RawData)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Nonce != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RawData) > 0 {
		i -= len(m.RawData)
		copy(dAtA[i:], m.RawData)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.RawData)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BlockTime != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.BlockTime))
		i--
		dAtA[i] = 0x20
	}
	if m.BlockHeight != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.Nonce != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PredefinedOracle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredefinedOracle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PredefinedOracle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOracle(dAtA []byte, offset int, v uint64) int {
	offset -= sovOracle(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OracleRequestDoc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != 0 {
		n += 1 + sovOracle(uint64(m.RequestId))
	}
	if m.OracleType != 0 {
		n += 1 + sovOracle(uint64(m.OracleType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.Period != 0 {
		n += 1 + sovOracle(uint64(m.Period))
	}
	if len(m.AccountList) > 0 {
		for _, s := range m.AccountList {
			l = len(s)
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if m.Quorum != 0 {
		n += 1 + sovOracle(uint64(m.Quorum))
	}
	if len(m.Endpoints) > 0 {
		for _, e := range m.Endpoints {
			l = e.Size()
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if m.AggregationRule != 0 {
		n += 1 + sovOracle(uint64(m.AggregationRule))
	}
	if m.Status != 0 {
		n += 1 + sovOracle(uint64(m.Status))
	}
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovOracle(uint64(m.Nonce))
	}
	return n
}

func (m *OracleEndpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.ParseRule)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *SubmitDataSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != 0 {
		n += 1 + sovOracle(uint64(m.RequestId))
	}
	if m.Nonce != 0 {
		n += 1 + sovOracle(uint64(m.Nonce))
	}
	l = len(m.RawData)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *DataSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != 0 {
		n += 1 + sovOracle(uint64(m.RequestId))
	}
	if m.Nonce != 0 {
		n += 1 + sovOracle(uint64(m.Nonce))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovOracle(uint64(m.BlockHeight))
	}
	if m.BlockTime != 0 {
		n += 1 + sovOracle(uint64(m.BlockTime))
	}
	l = len(m.RawData)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *PredefinedOracle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovOracle(uint64(m.Type))
	}
	if m.RequestId != 0 {
		n += 1 + sovOracle(uint64(m.RequestId))
	}
	return n
}

func sovOracle(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOracle(x uint64) (n int) {
	return sovOracle(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OracleRequestDoc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleRequestDoc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleRequestDoc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			m.Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Period |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountList = append(m.AccountList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quorum", wireType)
			}
			m.Quorum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quorum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, &OracleEndpoint{})
			if err := m.Endpoints[len(m.Endpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationRule", wireType)
			}
			m.AggregationRule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AggregationRule |= AggregationRule(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= RequestStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleEndpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleEndpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseRule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseRule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitDataSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitDataSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitDataSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredefinedOracle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredefinedOracle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredefinedOracle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PredefinedOracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOracle(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOracle
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOracle
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOracle
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOracle        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOracle          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOracle = fmt.Errorf("proto: unexpected end of group")
)
