// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: guru/oracle/v1/oracle.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// OracleType defines the type of oracle data that can be requested and provided
// This enum helps categorize different kinds of oracle data sources and their purposes
type OracleType int32

const (
	// Default value, should not be used
	OracleType_ORACLE_TYPE_UNSPECIFIED OracleType = 0
	// Minimum gas price oracle for network fee estimation
	OracleType_ORACLE_TYPE_MIN_GAS_PRICE OracleType = 1
	// Currency exchange rates and forex data
	OracleType_ORACLE_TYPE_CURRENCY OracleType = 2
	// Stock market data and indices
	OracleType_ORACLE_TYPE_STOCK OracleType = 3
	// Cryptocurrency prices and market data
	OracleType_ORACLE_TYPE_CRYPTO OracleType = 4
)

var OracleType_name = map[int32]string{
	0: "ORACLE_TYPE_UNSPECIFIED",
	1: "ORACLE_TYPE_MIN_GAS_PRICE",
	2: "ORACLE_TYPE_CURRENCY",
	3: "ORACLE_TYPE_STOCK",
	4: "ORACLE_TYPE_CRYPTO",
}

var OracleType_value = map[string]int32{
	"ORACLE_TYPE_UNSPECIFIED":   0,
	"ORACLE_TYPE_MIN_GAS_PRICE": 1,
	"ORACLE_TYPE_CURRENCY":      2,
	"ORACLE_TYPE_STOCK":         3,
	"ORACLE_TYPE_CRYPTO":        4,
}

func (x OracleType) String() string {
	return proto.EnumName(OracleType_name, int32(x))
}

func (OracleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{0}
}

// RequestStatus defines the current state of an oracle request
// This helps track the lifecycle of oracle data requests
type RequestStatus int32

const (
	// Default value, should not be used
	RequestStatus_REQUEST_STATUS_UNSPECIFIED RequestStatus = 0
	// Request is waiting to be processed
	RequestStatus_REQUEST_STATUS_PENDING RequestStatus = 1
	// Request was successfully processed and data is available
	RequestStatus_REQUEST_STATUS_SUCCESS RequestStatus = 2
	// Request failed to process or data is invalid
	RequestStatus_REQUEST_STATUS_FAILED RequestStatus = 3
	// Request was stopped or cancelled
	RequestStatus_REQUEST_STATUS_STOP RequestStatus = 4
)

var RequestStatus_name = map[int32]string{
	0: "REQUEST_STATUS_UNSPECIFIED",
	1: "REQUEST_STATUS_PENDING",
	2: "REQUEST_STATUS_SUCCESS",
	3: "REQUEST_STATUS_FAILED",
	4: "REQUEST_STATUS_STOP",
}

var RequestStatus_value = map[string]int32{
	"REQUEST_STATUS_UNSPECIFIED": 0,
	"REQUEST_STATUS_PENDING":     1,
	"REQUEST_STATUS_SUCCESS":     2,
	"REQUEST_STATUS_FAILED":      3,
	"REQUEST_STATUS_STOP":        4,
}

func (x RequestStatus) String() string {
	return proto.EnumName(RequestStatus_name, int32(x))
}

func (RequestStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{1}
}

// AggregationRule defines the enumeration for aggregating oracle data
// Specifies how multiple data points should be combined into a single value
type AggregationRule int32

const (
	// Default value, should not be used
	AggregationRule_AGGREGATION_RULE_UNSPECIFIED AggregationRule = 0
	// Use average value to aggregate the data
	AggregationRule_AGGREGATION_RULE_AVG AggregationRule = 1
	// Use minimum value to aggregate the data
	AggregationRule_AGGREGATION_RULE_MIN AggregationRule = 2
	// Use maximum value to aggregate the data
	AggregationRule_AGGREGATION_RULE_MAX AggregationRule = 3
)

var AggregationRule_name = map[int32]string{
	0: "AGGREGATION_RULE_UNSPECIFIED",
	1: "AGGREGATION_RULE_AVG",
	2: "AGGREGATION_RULE_MIN",
	3: "AGGREGATION_RULE_MAX",
}

var AggregationRule_value = map[string]int32{
	"AGGREGATION_RULE_UNSPECIFIED": 0,
	"AGGREGATION_RULE_AVG":         1,
	"AGGREGATION_RULE_MIN":         2,
	"AGGREGATION_RULE_MAX":         3,
}

func (x AggregationRule) String() string {
	return proto.EnumName(AggregationRule_name, int32(x))
}

func (AggregationRule) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{2}
}

// RequestOracleDoc defines the structure for oracle request documents
// This is the main document that describes what oracle data is needed and how it should be processed
type RequestOracleDoc struct {
	// Unique identifier for the oracle request
	RequestId uint64 `protobuf:"varint,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Type of oracle data being requested
	OracleType OracleType `protobuf:"varint,2,opt,name=oracle_type,json=oracleType,proto3,enum=guru.oracle.v1.OracleType" json:"oracle_type,omitempty"`
	// Human-readable name for the oracle request
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Detailed description of what data is needed and its purpose
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Time period in seconds between data updates
	Period uint32 `protobuf:"varint,5,opt,name=period,proto3" json:"period,omitempty"`
	// List of node(account) addresses that are authorized to provide data
	NodeList []string `protobuf:"bytes,6,rep,name=node_list,json=nodeList,proto3" json:"node_list,omitempty"`
	// Source URLs where the data can be fetched
	Urls []string `protobuf:"bytes,7,rep,name=urls,proto3" json:"urls,omitempty"`
	// JSONPath or similar rule to parse the raw data
	ParseRule string `protobuf:"bytes,8,opt,name=parse_rule,json=parseRule,proto3" json:"parse_rule,omitempty"`
	// Rule for aggregating multiple data points (e.g., median, mean)
	AggregateRule AggregationRule `protobuf:"varint,9,opt,name=aggregate_rule,json=aggregateRule,proto3,enum=guru.oracle.v1.AggregationRule" json:"aggregate_rule,omitempty"`
	// Current status of the request
	Status RequestStatus `protobuf:"varint,10,opt,name=status,proto3,enum=guru.oracle.v1.RequestStatus" json:"status,omitempty"`
	// Address of the request creator
	Creator string `protobuf:"bytes,11,opt,name=creator,proto3" json:"creator,omitempty"`
	// Sequential number to ensure data freshness
	Nonce uint64 `protobuf:"varint,12,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *RequestOracleDoc) Reset()         { *m = RequestOracleDoc{} }
func (m *RequestOracleDoc) String() string { return proto.CompactTextString(m) }
func (*RequestOracleDoc) ProtoMessage()    {}
func (*RequestOracleDoc) Descriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{0}
}
func (m *RequestOracleDoc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestOracleDoc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestOracleDoc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestOracleDoc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestOracleDoc.Merge(m, src)
}
func (m *RequestOracleDoc) XXX_Size() int {
	return m.Size()
}
func (m *RequestOracleDoc) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestOracleDoc.DiscardUnknown(m)
}

var xxx_messageInfo_RequestOracleDoc proto.InternalMessageInfo

func (m *RequestOracleDoc) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *RequestOracleDoc) GetOracleType() OracleType {
	if m != nil {
		return m.OracleType
	}
	return OracleType_ORACLE_TYPE_UNSPECIFIED
}

func (m *RequestOracleDoc) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RequestOracleDoc) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RequestOracleDoc) GetPeriod() uint32 {
	if m != nil {
		return m.Period
	}
	return 0
}

func (m *RequestOracleDoc) GetNodeList() []string {
	if m != nil {
		return m.NodeList
	}
	return nil
}

func (m *RequestOracleDoc) GetUrls() []string {
	if m != nil {
		return m.Urls
	}
	return nil
}

func (m *RequestOracleDoc) GetParseRule() string {
	if m != nil {
		return m.ParseRule
	}
	return ""
}

func (m *RequestOracleDoc) GetAggregateRule() AggregationRule {
	if m != nil {
		return m.AggregateRule
	}
	return AggregationRule_AGGREGATION_RULE_UNSPECIFIED
}

func (m *RequestOracleDoc) GetStatus() RequestStatus {
	if m != nil {
		return m.Status
	}
	return RequestStatus_REQUEST_STATUS_UNSPECIFIED
}

func (m *RequestOracleDoc) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *RequestOracleDoc) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

// SubmitDataSet defines the structure for oracle data sets for submit
// This represents a single data point provided by an oracle node
type SubmitDataSet struct {
	// ID of the request this data set belongs to
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Sequential number to prevent replay attacks
	Nonce uint64 `protobuf:"varint,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Raw data in string format (can be JSON, CSV, etc.)
	RawData string `protobuf:"bytes,3,opt,name=raw_data,json=rawData,proto3" json:"raw_data,omitempty"`
	// Address of the data provider
	Provider string `protobuf:"bytes,4,opt,name=provider,proto3" json:"provider,omitempty"`
	// Cryptographic signature of the data for verification
	Signature string `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *SubmitDataSet) Reset()         { *m = SubmitDataSet{} }
func (m *SubmitDataSet) String() string { return proto.CompactTextString(m) }
func (*SubmitDataSet) ProtoMessage()    {}
func (*SubmitDataSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{1}
}
func (m *SubmitDataSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitDataSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitDataSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitDataSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitDataSet.Merge(m, src)
}
func (m *SubmitDataSet) XXX_Size() int {
	return m.Size()
}
func (m *SubmitDataSet) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitDataSet.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitDataSet proto.InternalMessageInfo

func (m *SubmitDataSet) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *SubmitDataSet) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *SubmitDataSet) GetRawData() string {
	if m != nil {
		return m.RawData
	}
	return ""
}

func (m *SubmitDataSet) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *SubmitDataSet) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

// DataSet defines the structure for oracle data sets
type DataSet struct {
	// ID of the request this data set belongs to
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Sequential number to prevent replay attacks
	Nonce uint64 `protobuf:"varint,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Block height - represents the height of the block where the data was aggregated
	BlockHeight uint64 `protobuf:"varint,3,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	// Raw data in string format (can be JSON, CSV, etc.)
	RawData string `protobuf:"bytes,4,opt,name=raw_data,json=rawData,proto3" json:"raw_data,omitempty"`
}

func (m *DataSet) Reset()         { *m = DataSet{} }
func (m *DataSet) String() string { return proto.CompactTextString(m) }
func (*DataSet) ProtoMessage()    {}
func (*DataSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f372f15f6da5f250, []int{2}
}
func (m *DataSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSet.Merge(m, src)
}
func (m *DataSet) XXX_Size() int {
	return m.Size()
}
func (m *DataSet) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSet.DiscardUnknown(m)
}

var xxx_messageInfo_DataSet proto.InternalMessageInfo

func (m *DataSet) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *DataSet) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *DataSet) GetBlockHeight() uint64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *DataSet) GetRawData() string {
	if m != nil {
		return m.RawData
	}
	return ""
}

func init() {
	proto.RegisterEnum("guru.oracle.v1.OracleType", OracleType_name, OracleType_value)
	proto.RegisterEnum("guru.oracle.v1.RequestStatus", RequestStatus_name, RequestStatus_value)
	proto.RegisterEnum("guru.oracle.v1.AggregationRule", AggregationRule_name, AggregationRule_value)
	proto.RegisterType((*RequestOracleDoc)(nil), "guru.oracle.v1.RequestOracleDoc")
	proto.RegisterType((*SubmitDataSet)(nil), "guru.oracle.v1.SubmitDataSet")
	proto.RegisterType((*DataSet)(nil), "guru.oracle.v1.DataSet")
}

func init() { proto.RegisterFile("guru/oracle/v1/oracle.proto", fileDescriptor_f372f15f6da5f250) }

var fileDescriptor_f372f15f6da5f250 = []byte{
	// 756 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0x41, 0x73, 0xdb, 0x44,
	0x14, 0x8e, 0x6c, 0x37, 0x89, 0x5e, 0x9a, 0x20, 0x96, 0x34, 0x55, 0x9c, 0x46, 0x35, 0x39, 0x79,
	0x32, 0x83, 0x35, 0x81, 0xe1, 0xc4, 0x49, 0xc8, 0x8a, 0xd1, 0x90, 0xda, 0x66, 0x25, 0x33, 0x84,
	0x8b, 0x66, 0x25, 0x2f, 0x8a, 0x06, 0x59, 0x2b, 0x56, 0xab, 0xb4, 0x9d, 0xe1, 0xc2, 0x3f, 0x80,
	0x23, 0xc3, 0x4f, 0xe1, 0x0f, 0x70, 0xec, 0x91, 0x23, 0x93, 0xfc, 0x11, 0x46, 0x6b, 0xd5, 0xb5,
	0xd5, 0xdc, 0x7a, 0x7b, 0xef, 0xfb, 0xde, 0x7b, 0xfb, 0xed, 0x7e, 0x3b, 0x0f, 0x4e, 0xe2, 0x92,
	0x97, 0x26, 0xe3, 0x24, 0x4a, 0xa9, 0x79, 0x7b, 0x51, 0x47, 0x83, 0x9c, 0x33, 0xc1, 0xd0, 0x41,
	0x45, 0x0e, 0x6a, 0xe8, 0xf6, 0xa2, 0x7b, 0x18, 0xb3, 0x98, 0x49, 0xca, 0xac, 0xa2, 0x65, 0x55,
	0xf7, 0x79, 0xcc, 0x58, 0x9c, 0x52, 0x53, 0x66, 0x61, 0xf9, 0x93, 0x29, 0x92, 0x05, 0x2d, 0x04,
	0x59, 0xe4, 0x75, 0x81, 0x11, 0xb1, 0x62, 0xc1, 0x0a, 0x33, 0x24, 0x45, 0x75, 0x46, 0x48, 0x05,
	0xb9, 0x30, 0x23, 0x96, 0x64, 0x4b, 0xfe, 0xec, 0xef, 0x36, 0x68, 0x98, 0xfe, 0x52, 0xd2, 0x42,
	0x4c, 0xe4, 0x59, 0x43, 0x16, 0xa1, 0x53, 0x00, 0xbe, 0xc4, 0x82, 0x64, 0xae, 0x2b, 0x3d, 0xa5,
	0xdf, 0xc1, 0x6a, 0x8d, 0xb8, 0x73, 0xf4, 0x15, 0xec, 0x2d, 0x75, 0x05, 0xe2, 0x75, 0x4e, 0xf5,
	0x56, 0x4f, 0xe9, 0x1f, 0x7c, 0xde, 0x1d, 0x6c, 0x0a, 0x1e, 0x2c, 0xc7, 0xf9, 0xaf, 0x73, 0x8a,
	0x81, 0xad, 0x62, 0x84, 0xa0, 0x93, 0x91, 0x05, 0xd5, 0xdb, 0x3d, 0xa5, 0xaf, 0x62, 0x19, 0xa3,
	0x1e, 0xec, 0xcd, 0x69, 0x11, 0xf1, 0x24, 0x17, 0x09, 0xcb, 0xf4, 0x8e, 0xa4, 0xd6, 0x21, 0x74,
	0x04, 0xdb, 0x39, 0xe5, 0x09, 0x9b, 0xeb, 0x8f, 0x7a, 0x4a, 0x7f, 0x1f, 0xd7, 0x19, 0x3a, 0x01,
	0x35, 0x63, 0x73, 0x1a, 0xa4, 0x49, 0x21, 0xf4, 0xed, 0x5e, 0xbb, 0xaf, 0xe2, 0xdd, 0x0a, 0xb8,
	0x4a, 0x0a, 0x51, 0x1d, 0x55, 0xf2, 0xb4, 0xd0, 0x77, 0x24, 0x2e, 0xe3, 0xea, 0x6a, 0x39, 0xe1,
	0x05, 0x0d, 0x78, 0x99, 0x52, 0x7d, 0x57, 0x9e, 0xa4, 0x4a, 0x04, 0x97, 0x29, 0x45, 0x97, 0x70,
	0x40, 0xe2, 0x98, 0xd3, 0x98, 0x88, 0xba, 0x44, 0x95, 0xb7, 0x7b, 0xde, 0xbc, 0x9d, 0x55, 0x57,
	0x25, 0x2c, 0xab, 0x1a, 0xf1, 0xfe, 0xaa, 0x4d, 0xce, 0xf9, 0x12, 0xb6, 0x0b, 0x41, 0x44, 0x59,
	0xe8, 0x20, 0xfb, 0x4f, 0x9b, 0xfd, 0xf5, 0x9b, 0x7b, 0xb2, 0x08, 0xd7, 0xc5, 0x48, 0x87, 0x9d,
	0x88, 0x53, 0x22, 0x18, 0xd7, 0xf7, 0xa4, 0xb4, 0xb7, 0x29, 0x3a, 0x84, 0x47, 0x19, 0xcb, 0x22,
	0xaa, 0x3f, 0x96, 0x6e, 0x2c, 0x93, 0xb3, 0x3f, 0x15, 0xd8, 0xf7, 0xca, 0x70, 0x91, 0x88, 0x21,
	0x11, 0xc4, 0xa3, 0xe2, 0x01, 0xeb, 0xd4, 0x75, 0xeb, 0x56, 0x63, 0x5a, 0x6b, 0x63, 0xd0, 0x31,
	0xec, 0x72, 0xf2, 0x32, 0x98, 0x13, 0x41, 0x6a, 0x5f, 0x76, 0x38, 0x79, 0x59, 0x8d, 0x44, 0x5d,
	0xd8, 0xcd, 0x39, 0xbb, 0x4d, 0xe6, 0x94, 0xd7, 0xbe, 0xac, 0x72, 0xf4, 0x0c, 0xd4, 0x22, 0x89,
	0x33, 0x22, 0x4a, 0x4e, 0xa5, 0x2f, 0x2a, 0x7e, 0x07, 0x9c, 0xfd, 0x0a, 0x3b, 0x1f, 0x24, 0xea,
	0x53, 0x78, 0x1c, 0xa6, 0x2c, 0xfa, 0x39, 0xb8, 0xa1, 0x49, 0x7c, 0x23, 0xa4, 0xb0, 0x0e, 0xde,
	0x93, 0xd8, 0x37, 0x12, 0xda, 0xd0, 0xdd, 0xd9, 0xd0, 0x7d, 0xfe, 0x87, 0x02, 0xf0, 0xee, 0x07,
	0xa2, 0x13, 0x78, 0x3a, 0xc1, 0x96, 0x7d, 0xe5, 0x04, 0xfe, 0xf5, 0xd4, 0x09, 0x66, 0x63, 0x6f,
	0xea, 0xd8, 0xee, 0xa5, 0xeb, 0x0c, 0xb5, 0x2d, 0x74, 0x0a, 0xc7, 0xeb, 0xe4, 0x0b, 0x77, 0x1c,
	0x8c, 0x2c, 0x2f, 0x98, 0x62, 0xd7, 0x76, 0x34, 0x05, 0xe9, 0x70, 0xb8, 0x4e, 0xdb, 0x33, 0x8c,
	0x9d, 0xb1, 0x7d, 0xad, 0xb5, 0xd0, 0x13, 0xf8, 0x78, 0x9d, 0xf1, 0xfc, 0x89, 0xfd, 0xad, 0xd6,
	0x46, 0x47, 0x80, 0x36, 0x1a, 0xf0, 0xf5, 0xd4, 0x9f, 0x68, 0x9d, 0xf3, 0xbf, 0x14, 0xd8, 0xdf,
	0xf0, 0x1d, 0x19, 0xd0, 0xc5, 0xce, 0x77, 0x33, 0xc7, 0xf3, 0x03, 0xcf, 0xb7, 0xfc, 0x99, 0xd7,
	0x50, 0xd6, 0x85, 0xa3, 0x06, 0x3f, 0x75, 0xc6, 0x43, 0x77, 0x3c, 0xd2, 0x94, 0x07, 0x38, 0x6f,
	0x66, 0xdb, 0x8e, 0xe7, 0x69, 0x2d, 0x74, 0x0c, 0x4f, 0x1a, 0xdc, 0xa5, 0xe5, 0x5e, 0x39, 0x43,
	0xad, 0x8d, 0x9e, 0xc2, 0x27, 0xcd, 0x36, 0x7f, 0x32, 0xd5, 0x3a, 0xe7, 0xbf, 0x29, 0xf0, 0x51,
	0xe3, 0x57, 0xa3, 0x1e, 0x3c, 0xb3, 0x46, 0x23, 0xec, 0x8c, 0x2c, 0xdf, 0x9d, 0x8c, 0x03, 0x3c,
	0xbb, 0x6a, 0xbe, 0x9d, 0x0e, 0x87, 0xef, 0x55, 0x58, 0xdf, 0x8f, 0x96, 0xcf, 0xf6, 0x1e, 0xf3,
	0xc2, 0x1d, 0x6b, 0xad, 0x87, 0x19, 0xeb, 0x07, 0xad, 0xfd, 0xf5, 0xf0, 0x9f, 0x3b, 0x43, 0x79,
	0x73, 0x67, 0x28, 0xff, 0xdd, 0x19, 0xca, 0xef, 0xf7, 0xc6, 0xd6, 0x9b, 0x7b, 0x63, 0xeb, 0xdf,
	0x7b, 0x63, 0xeb, 0xc7, 0xf3, 0x38, 0x11, 0x37, 0x65, 0x38, 0x88, 0xd8, 0xc2, 0x1c, 0x4d, 0xfd,
	0x57, 0x9f, 0xc5, 0x29, 0x0b, 0x49, 0x6a, 0xca, 0x15, 0xfa, 0xea, 0xed, 0x12, 0xad, 0xf6, 0x51,
	0x11, 0x6e, 0xcb, 0xd5, 0xf6, 0xc5, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x35, 0xbe, 0xc2, 0xd0,
	0x60, 0x05, 0x00, 0x00,
}

func (m *RequestOracleDoc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestOracleDoc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestOracleDoc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Status != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	if m.AggregateRule != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.AggregateRule))
		i--
		dAtA[i] = 0x48
	}
	if len(m.ParseRule) > 0 {
		i -= len(m.ParseRule)
		copy(dAtA[i:], m.ParseRule)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.ParseRule)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Urls) > 0 {
		for iNdEx := len(m.Urls) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Urls[iNdEx])
			copy(dAtA[i:], m.Urls[iNdEx])
			i = encodeVarintOracle(dAtA, i, uint64(len(m.Urls[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.NodeList) > 0 {
		for iNdEx := len(m.NodeList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NodeList[iNdEx])
			copy(dAtA[i:], m.NodeList[iNdEx])
			i = encodeVarintOracle(dAtA, i, uint64(len(m.NodeList[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Period != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Period))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OracleType != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.OracleType))
		i--
		dAtA[i] = 0x10
	}
	if m.RequestId != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubmitDataSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitDataSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubmitDataSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RawData) > 0 {
		i -= len(m.RawData)
		copy(dAtA[i:], m.RawData)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.RawData)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Nonce != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RawData) > 0 {
		i -= len(m.RawData)
		copy(dAtA[i:], m.RawData)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.RawData)))
		i--
		dAtA[i] = 0x22
	}
	if m.BlockHeight != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.Nonce != 0 {
		i = encodeVarintOracle(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintOracle(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintOracle(dAtA []byte, offset int, v uint64) int {
	offset -= sovOracle(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RequestOracleDoc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestId != 0 {
		n += 1 + sovOracle(uint64(m.RequestId))
	}
	if m.OracleType != 0 {
		n += 1 + sovOracle(uint64(m.OracleType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.Period != 0 {
		n += 1 + sovOracle(uint64(m.Period))
	}
	if len(m.NodeList) > 0 {
		for _, s := range m.NodeList {
			l = len(s)
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	if len(m.Urls) > 0 {
		for _, s := range m.Urls {
			l = len(s)
			n += 1 + l + sovOracle(uint64(l))
		}
	}
	l = len(m.ParseRule)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.AggregateRule != 0 {
		n += 1 + sovOracle(uint64(m.AggregateRule))
	}
	if m.Status != 0 {
		n += 1 + sovOracle(uint64(m.Status))
	}
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovOracle(uint64(m.Nonce))
	}
	return n
}

func (m *SubmitDataSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovOracle(uint64(m.Nonce))
	}
	l = len(m.RawData)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func (m *DataSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovOracle(uint64(m.Nonce))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovOracle(uint64(m.BlockHeight))
	}
	l = len(m.RawData)
	if l > 0 {
		n += 1 + l + sovOracle(uint64(l))
	}
	return n
}

func sovOracle(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOracle(x uint64) (n int) {
	return sovOracle(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RequestOracleDoc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestOracleDoc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestOracleDoc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleType", wireType)
			}
			m.OracleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OracleType |= OracleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			m.Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Period |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeList = append(m.NodeList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Urls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Urls = append(m.Urls, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseRule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParseRule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateRule", wireType)
			}
			m.AggregateRule = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AggregateRule |= AggregationRule(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= RequestStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitDataSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitDataSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitDataSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOracle
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOracle
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOracle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOracle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOracle(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOracle
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOracle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOracle
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOracle
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOracle
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOracle        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOracle          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOracle = fmt.Errorf("proto: unexpected end of group")
)
